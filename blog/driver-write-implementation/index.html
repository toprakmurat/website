<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="../../static/style.css">
<body>
  <header>
    <h1>Murat Toprak</h1>
    <nav>
      <ul class="nav navbar-nav">
        <li><a href="../../">Home</a></li>
        
          <li class="active"><a href="../">Blog</a></li>
        
          <li><a href="../../about/">About</a></li>
        
      </ul>
    </nav>
  </header>
  <div class="page" style="text-align: justify;">
    
  <link rel="stylesheet" href="../../static/pygments.css">
  <div style="text-align: justify;">
    <!-- Rendering blog post content -->
    
  <div class="blog-post">
  
    <h2 style="text-align: center;">Implementing pseudo device driver</h2>
  
  <p>I attend system programming workshop instructed by <a href="https://github.com/uyar">H. Turgut Uyar</a> at ITU which is kind of challenging and at the same time very fun for me.</p>
<h4>Third Assignment</h4>
<p>Third assignment(first two was relatively easy) in our workshop is to implement a circular write operation for our pseudo driver.</p>
<p>I first wrote this structure below. I wanted to write as simple as possible to tinker with the driver and find the flaws.</p>
<div class="hll"><pre><span></span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">pseudo</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_</span><span class="w"> </span><span class="n">INFO</span><span class="w"> </span><span class="s">&quot;pseudo: writing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Check availability</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">down_</span><span class="w"> </span><span class="n">interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_</span><span class="w"> </span><span class="n">sem</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f_pos</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_from</span><span class="w"> </span><span class="n">user</span><span class="p">(</span><span class="n">pseudo_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_sem</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="o">:</span>
</pre></div>
<p>First flaw is that I gave capacity parameter 50 and wrote a 70 character string. However, I found out that this code only works well for under the given capacity parameter(in this case 50).</p>
<p>First <em>f_pos: 0 and count: 50, then </em>f_pos becomes 50. So, count becomes zero when I subtract *f_pos from capacity(both are 50) when function is called again.</p>
<pre><code>write(1,
"EY MUAD DIB YOU ARE THE MESSIAH
.., 70) = 50
write(1, "G TO THE DESERT MAN\n", 20) = 0
write(1, "G TO THE DESERT MAN\n", 20) = 0
write(1, "G TO THE DESERT MANIn", 20) = 0
write(1, "G TO THE DESERT MAN\n', 20) = 0
write(1, "G TO THE DESERT MAN\n", 20) = 0
...
...
...
</code></pre>
<p>To fix this issue, I added another if statement</p>
<div class="hll"><pre><span></span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">pseudo</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN</span><span class="w"> </span><span class="n">INFO</span><span class="w"> </span><span class="s">&quot;pseudo: writing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Check availability</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">down_</span><span class="w"> </span><span class="n">interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_</span><span class="w"> </span><span class="n">sem</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// wrote all</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="p">,</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo</span><span class="w"> </span><span class="n">sem</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// partial write</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_from</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="n">pseudo</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">up</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_sem</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
</pre></div>
<p>As I said in the beginning, I love keeping thing simple at first. Now I know that I should add error checking a little. After adding a pinch of 'syntactic sugar', my write operation will be ready.</p>
<div class="hll"><pre><span></span><span class="kt">ssize_t</span><span class="w"> </span><span class="nf">pseudo_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Check availability</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_sem</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// wrote all</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// partial write</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// where the magic happens</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">pseudo_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">f_pos</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_sem</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f_pos</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>

<span class="nl">out</span><span class="p">:</span>
<span class="w">    </span><span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pseudo_sem</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h4>Fourth Assignment</h4>
<p>The forth assignment is to implement the seek operation. I did not know what seek operation means but I found that it is basically moving the file pointer by the specified offset parameter.</p>
<div class="hll"><pre><span></span><span class="n">loff_t</span><span class="w"> </span><span class="nf">pseudo_llseek</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">whence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">loff_t</span><span class="w"> </span><span class="n">newpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">whence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// SEEK_SET: from beginning, SEEK_CUR: from current, SEEK_END: from end</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SEEK_SET</span><span class="p">:</span><span class="w"> </span>
<span class="w">        </span><span class="n">newpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SEEK_CUR</span><span class="p">:</span>
<span class="w">        </span><span class="n">newpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SEEK_END</span><span class="p">:</span>
<span class="w">        </span><span class="n">newpos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// default can&#39;t happen</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">newpos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">newpos</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newpos</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">newpos</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Let's have a look at the function parameters:<br>
<code>struct file *filp:</code> file pointer on which this seek operation will be performed</p>
<p><code>loff_t off:</code> loff_t is a linux data type which is defined as long long. Usually, _t implies that it is a type in C. So, loff_t is a data type that is long long and specifies file offsets in linux kernel.</p>
<p><code>int whence:</code> this parameter specifies from where the offset parameter will start. There are three possible parameters which are SEEK_SET, SEEK_CUR and SEEK_END. These are just macros and their values 0, 1, 2, respectively. (Typical enumeration)</p>
<p>So what this function does is it moves the f_pos pointer by the offset value based on the <code>whence</code> parameter and returns the new position of the f_pos pointer.</p>
<h4>Fifth Assignment</h4>
<p>The fifth assignment is to implement an ioctl operation named "PSEUDO_INC" which takes an 8-bit, signed integer value as parameter and increases each byte in the device by that value. It seemed a little complex at first but it is not difficult to implement.</p>
<p>IOCTL stands for "input-output control". This function can have different implementations according to your needs. In my case, it will take an 8-bit signed integer (which is char obviously). And as always I did not know how to do that. I found that getting parameter is a simple one line preprocessor statement:</p>
<p><code>#define PSEUDO_INC _IOW('p', 1, signed char)</code>
'p' is the unique identifier for the device</p>
<p>1 is the command number, Actually I don't know anything more, I wrote 1 because every example I saw had written 1 in this parameter.</p>
<p>signed char is the type of the parameter which we want to give to device.</p>
<p>Below is the code for this simple ioctl.</p>
<div class="hll"><pre><span></span><span class="cm">/* unlocked ioctl, without taking the file&#39;s lock */</span>
<span class="kt">long</span><span class="w"> </span><span class="nf">pseudo_ioctl</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">filp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">increment</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PSEUDO_INC</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// Copy the ioctl argument from user space to kernel space</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">increment</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Perform the PSEUDO_INC operation</span>
<span class="w">        </span><span class="c1">// iterate over each byte in the device buffer and increment that byte with the given value</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pseudo_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">increment</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span><span class="w">  </span><span class="c1">// invalid ioctl</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>This function is so simple, it just increments the content of the pre-defined and pre-filled buffer by the specified value using a for loop. I want to emphasize that ioctl is often done by without taking the file's lock beceause the kernel ensures that ioctl commands are executed in an isolated and consistent manner.</p>
<h4>Sixth Assignment</h4>
<p>The instruction for the sixth assignment is "At the moment, the device node has to be created manually after inserting the module. Handle this automatically without the need for human intervention." I was doing <code>sudo mknod /dev/pseudo c 240 0</code> to create the node after inserting the module. Now, this should be done automatically.</p>
<p>We need to define two things, a device class and a device node. These are global variables.</p>
<div class="hll"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">class</span><span class="w"> </span><span class="o">*</span><span class="n">pseudo_class</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">pseudo_device</span><span class="p">;</span>
</pre></div>
<p>Then inside the open function (in my case pseudo_open) we need to create the class and node.</p>
<div class="hll"><pre><span></span><span class="c1">// Create a device class</span>
<span class="n">pseudo_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">class_create</span><span class="p">(</span><span class="s">&quot;pseudo&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pseudo_class</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="w"> </span><span class="s">&quot;pseudo: failed to register device class</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pseudo_class</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create the device node</span>
<span class="cm">/* </span>
<span class="cm">struct device *device_create(</span>
<span class="cm">    struct class *class: device class to which the new device belongs, </span>
<span class="cm">    struct device *parent: parent device of the new device, NULL if not, </span>
<span class="cm">    dev_t devt: device number of the new device,</span>
<span class="cm">    void *drvdata: device specific data, NULL if not, </span>
<span class="cm">    const char *fmt: name of the new device,</span>
<span class="cm">    ...);</span>
<span class="cm">*/</span>
<span class="n">pseudo_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_create</span><span class="p">(</span><span class="n">pseudo_class</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">devno</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pseudo&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pseudo_device</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="w"> </span><span class="s">&quot;pseudo: failed to create the device node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pseudo_device</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="w"> </span><span class="s">&quot;pseudo: device has been created successfully&quot;</span><span class="p">);</span>
</pre></div>
<p>These are just typical functions from kernel. I added explanations of the parameters of device_create in case I forget.</p>
<p>There is one more thing to do: we need to destroy this class and device when exit function is called (in my case pseudo_exit).</p>
<div class="hll"><pre><span></span><span class="c1">// Remove the device node</span>
<span class="n">device_destroy</span><span class="p">(</span><span class="n">pseudo_class</span><span class="p">,</span><span class="w"> </span><span class="n">devno</span><span class="p">);</span>

<span class="c1">// Remove the device class</span>
<span class="n">class_destroy</span><span class="p">(</span><span class="n">pseudo_class</span><span class="p">);</span>
</pre></div>
<h4>Seventh Assignment</h4>
<p>The last assignment is to "Add an entry for the device under the /proc file system, like /proc/pseudo.This entry should report the device capacity."</p>
<p>Again, I did not know what /proc filesystem is and found that it is a virtual file system to give ability to user space programs to retrieve information about kernel and system information. This filesystem exists in memory, that's why it is called virtual file system. I often think about these geniuses that come up with these kind of ideas. Maybe that could be the subject of another post.<br>
(proc stands for process information)</p>
<div class="hll"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">proc_dir_entry</span><span class="w"> </span><span class="o">*</span><span class="n">pseudo_proc</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pseudo_proc_show</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;pseudo: capacity is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">pseudo_proc_open</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">inode</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">pseudo_proc_show</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc_ops</span><span class="w"> </span><span class="n">pseudo_proc_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">proc_open</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pseudo_proc_open</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">proc_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq_read</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">proc_lseek</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq_lseek</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">proc_release</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
<p>It is very much like creating the device under /dev file system but it is much easier as it is simpler.</p>
<p>Firsty, create a global varaiable for proc entry. Then, implement basic open and show functions. Finally, we must map these functions with the system calls.
(Do not forget to create and remove proc entries in init and exit functions)</p>
<div class="hll"><pre><span></span><span class="c1">// in init function (pseudo_init)</span>
<span class="n">pseudo_proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;pseudo&quot;</span><span class="p">,</span><span class="w"> </span><span class="mo">0777</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pseudo_proc_ops</span><span class="p">);</span><span class="w"> </span>

<span class="c1">// in exit function (pseudo_exit)</span>
<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;pseudo&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
<p>Overall, these concepts, functions etc. seemed challenging at first glance (maybe because I'm a freshman) and I spent a considerable amount of time trying to understand them. However, I learned lots of things in the end. Next topic in the workshop is FUSE(filesystem in user space).</p>
<p>You can see the <a href="https://github.com/toprakmurat/system-programming-workshop">whole code</a></p>

  <em>
    <p class="meta" style="color: #00994c;">
    written by
    
      Murat Toprak
    
    on 2024-04-18
    </p>
  </em>
  </div>

    <!-- Rendering images -->
    <h2 style="text-align: center;">Gallery</h2>
    
    <!-- Rendering links to tags page -->
    <div class="tags">
      <h3>All posts tagged:</h3>
      <ul>
        <li>
            <a href="../tag/programming/">
            programming
            </a>
          </li>
        <li>
            <a href=".">
            C
            </a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  <footer>
    &copy; Copyright 2024 by Murat Toprak.
  </footer>
</body>
